<?php
// $Id$
// Original module written by Marco Scutari.
// Rewritten and considerably shortened and made more Drupal-friendly
// by Earl Miles.
// Yet again rewritten, extended and maintained by Gurpartap Singh.

function d($msg) {
  drupal_set_message('<pre>' . print_r($msg, TRUE) . '</pre>');
}

/**
 * Implementation of hook_help().
 */
function paging_help($path, $arg) {
  switch ($path) {
    case 'admin/help#paging':
      return '<p>' . t('Break long pages into smaller ones by means of a page break tag (e.g. %separator):</p>
<pre>First page here.
%separator
Second page here.
%separator
More pages here.</pre>', array('%separator' => '<!--pagebreak-->')) . '<p>' . t('Automatic page breaking based on character or word count is also supported.') . '</p>';
      break;
  }
}

/**
 * Implementation of hook_menu().
 */
function paging_menu() {
  $items = array();
  
  $items['admin/settings/paging'] = array(
    'title' => t('Paging'),
    'description' => t('Enable or disable paging, configure separator string, configure <em>Read more</em> link and toggle automatic paging for different content types.'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('paging_settings'),
    'access arguments' => array('administer site configuration'),
  );

  return $items;
}

/**
 * Menu callback; display module settings form.
 */
function paging_settings() {
  $form = array();

  // Set the id of the top-level form tag
  $form['#id'] = 'paging';

  $paging_filter = FALSE;
  // Retrieve all input filters.
  foreach (filter_formats() as $format) {
    // Further retrieve all input formats.
    foreach (filter_list_format($format->format) as $filter) {
      // Check if any of the input formats have paging filter enabled.
      if ($filter->module == 'paging') {
        $paging_filter = TRUE;
        break;
      }
    }
  }
  if (!$paging_filter) {
    drupal_set_message(t('Paging filter has not yet been enabled for any input formats. !link!', array('!link' => l(t('Take action'), 'admin/settings/filters'))), 'warning paging-warning');
  }

  foreach (node_get_types('names') as $type => $name) {
    $form[$type]['paging_config'] = array(
      '#type' => 'fieldset',
      '#title' => $name,
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
      '#attributes' => array('class' => 'paging-fieldset', 'id' => 'paging-type-' . $type),
    );
    $form[$type]['paging_config']['paging_left'] = array(
      '#type' => 'fieldset',
      '#collapsible' => FALSE,
      '#collapsed' => FALSE,
      '#attributes' => array('class' => 'paging-left'),
    );
    $form[$type]['paging_config']['paging_left']['paging_enabled_' . $type] = array(
      '#type' => 'checkbox',
      '#title' => '',
      '#default_value' => variable_get('paging_enabled_' . $type, 0),
      '#attributes' => array('class' => 'paging-enabled'),
    );
    $form[$type]['paging_config']['paging_left']['paging_separator_' . $type] = array(
      '#type' => 'textfield',
      '#title' => t('Page separator string'),
      '#size' => 20,
      '#maxlength' => 255,
      '#required' => TRUE,
      '#default_value' => variable_get('paging_separator_' . $type, '<!--pagebreak-->'),
      '#description' => t('Use an HTML tag that will render reasonably when paging is not enabled, such as %pagebreak or %hr.', array('%pagebreak' => '<!--pagebreak-->', '%hr' => '<hr />')),
    );
    $form[$type]['paging_config']['paging_left']['paging_read_more_enabled_' . $type] = array(
      '#type' => 'checkbox',
      '#title' => t('Link "Read more" to second page'),
      '#description' => t('When enabled, the "Read more" link under teasers will link to the second page of the content, iff the teaser is larger than the first page or if they are the same.'),
      '#default_value' => variable_get('paging_read_more_enabled_' . $type, 0),
    );

    $form[$type]['paging_config']['paging_right'] = array(
      '#type' => 'fieldset',
      '#collapsible' => FALSE,
      '#collapsed' => FALSE,
      '#attributes' => array('class' => 'paging-right'),
    );
    $form[$type]['paging_config']['paging_right']['paging_separator_widget_' . $type] = array(
      '#type' => 'radios',
      '#title' => t('Paging separator widget'),
      '#options' => array(t('Disabled'), t('Image'), t('Button'),
      ),
      '#required' => TRUE,
      '#description' => t('Choose the style of separator string widget. This widget attaches itself to the body textarea and when clicked, inserts separator at cursor position.'),
      '#default_value' => variable_get('paging_separator_widget_' . $type, 0),
      '#attributes' => array('class' => 'paging-method'),
    );
    $form[$type]['paging_config']['paging_right']['paging_automatic_method_' . $type] = array(
      '#type' => 'radios',
      '#title' => t('Automatic paging method'),
      '#options' => array(t('Disabled'), t('Limit by characters <small>(recommended)</small>'), t('Limit by words'),
      ),
      '#required' => TRUE,
      '#description' => t('Choose the method for automatic paging. Automatic paging is ignored where paging separator string is used.'),
      '#default_value' => variable_get('paging_automatic_method_' . $type, 0),
      '#attributes' => array('class' => 'paging-method'),
    );
    $form[$type]['paging_config']['paging_right']['paging_automatic_chars_' . $type] = array(
      '#type' => 'select',
      '#title' => t('Length of each page'),
      '#options' => array(
        500 => t('500 characters'), 750 => t('750 characters'),
        1000 => t('1000 characters'), 1500 => t('1500 characters'),
        2000 => t('2000 characters'), 2500 => t('2500 characters'),
        3000 => t('3000 characters'), 3500 => t('3500 characters'),
        4000 => t('4000 characters'), 4500 => t('4500 characters'),
        5000 => t('5000 characters'), 5500 => t('5500 characters'),
        6000 => t('6000 characters'), 6500 => t('6500 characters'),
        7000 => t('7000 characters'), 7500 => t('7500 characters'),
      ),
      '#required' => TRUE,
      '#description' => '<br />' . t('Select the number of characters to display per page.'),
      '#default_value' => variable_get('paging_automatic_chars_' . $type, 4000),
      '#prefix' => '<div class="container-inline paging-chars paging-chars-' . $type . '">',
      '#suffix' => '</div>',
    );

    $form[$type]['paging_config']['paging_right']['paging_automatic_words_' . $type] = array(
      '#type' => 'select',
      '#title' => t('Length of each page'),
      '#options' => array(
        50 => t('100 words'), 150 => t('150 words'),
        200 => t('200 words'), 250 => t('250 words'),
        300 => t('300 words'), 350 => t('350 words'),
        400 => t('400 words'), 450 => t('450 words'),
        500 => t('500 words'), 550 => t('550 words'),
        600 => t('600 words'), 650 => t('650 words'),
        700 => t('700 words'), 750 => t('750 words'),
      ),
      '#required' => TRUE,
      '#description' => '<br />' . t('Select the number of words to display per page.'),
      '#default_value' => variable_get('paging_automatic_words_' . $type, 400),
      '#prefix' => '<div class="container-inline paging-words paging-words-' . $type . '">',
      '#suffix' => '</div>',
    );
  }

  $form['paging_footer'] = array(
    '#value' => '<div id="paging-vertical-tabs"><ul class="ui-tabs-nav"></ul></div>',
  );

  // Vertical tabs:
  $module_path = drupal_get_path('module', 'paging');
  drupal_add_js($module_path . '/admin/jquery.cookie.min.js', 'module');
  drupal_add_js($module_path . '/admin/ui.tabs.min.js', 'module');
  drupal_add_js($module_path . '/admin/paging.admin.js', 'module');
  drupal_add_css($module_path . '/admin/paging.admin.css', 'module');

  return system_settings_form($form);
}

/**
 * Implementation of hook_form_alter().
 */
function paging_form_alter(&$form, $form_state, $form_id) {
  if (isset($form['type']) && isset($form['#node']) && variable_get('paging_enabled_' . $form['#node']->type, 0)) {
    $widget = variable_get('paging_separator_widget_' . $form['#node']->type, 0);
    $separator = variable_get('paging_separator_' . $form['#node']->type, '<!--pagesbreak-->');
    $module_path = drupal_get_path('module', 'paging');
    drupal_add_js(array('paging' => array('separator' => $separator, 'widget' => $widget, 'module_path' => $module_path)), 'setting');
    drupal_add_js($module_path . '/paging.js', 'module');
    drupal_add_css($module_path . '/paging.css', 'module');
  }
}

/**
 * Implementation of hook_nodeapi().
 */
function paging_nodeapi(&$node, $op, $teaser = NULL, $page = NULL) {
  if (variable_get('paging_enabled_' . $node->type, 0)) {
    switch ($op) {
      case 'load':
      case 'view':
      case 'alter':
        // Support for CCK.
        if (isset($node->field_body[0]['view'])) {
          _paging_nodeapi($node,
                          $node->field_body[0]['view'],
                          $node->field_teaser[0]['view'],
                          $op, $teaser, $page);
        }
        // Support for CCK.
        elseif (isset($node->field_body[0]['value'])) {
          _paging_nodeapi($node,
                          $node->field_body[0]['value'],
                          $node->field_teaser[0]['value'],
                          $op, $teaser, $page);
        }
        else {
          _paging_nodeapi($node, $node->body, $node->teaser, $op, $teaser, $page);
        }
        break;
      case 'prepare':
        // Pass the paging separator string for input format filter tips.
        $GLOBALS['paging_sep'] = variable_get('paging_separator_' . $node->type, '<!--pagebreak-->');
        break;
    }
  }
}

/**
 * Helper function for paging_nodeapi().
 */
function _paging_nodeapi(&$node, &$node_body, &$node_teaser, $op, $teaser, $page) {
  switch ($op) {
    case 'load':
      $paging_separator = variable_get('paging_separator_' . $node->type, '<!--pagebreak-->');
      if (strpos($teaser ? $node_teaser : $node_body, $paging_separator) !== FALSE) {
        // Manual page separators were used.
        $node->pages = explode($paging_separator, $node_body);
        $node->page_count = count($node->pages);
      }
      else {
        $body_parts = $node_body;
        if (variable_get('paging_automatic_method_' . $node->type, 0) == 1 && ($max_chars = variable_get('paging_automatic_chars_' . $node->type, 4000)) != 0) {
          // Automatic paging based on character count.
          $total_chars = strlen($node_body);
          if ($total_chars > $max_chars) {
            $body = $node_body;
            $breaks = (int)($total_chars / $max_chars);
            $bodypart = array();
            for ($i = 0; $i <= $breaks; $i++) {
              $bodypart[$i] = node_teaser(trim($body), NULL, $max_chars);
              $bodycount = strlen($bodypart[$i]);
              $body = substr($body, $bodycount);
            }
            $body_parts = implode($paging_separator, $bodypart);
          }
        }
        elseif (variable_get('paging_automatic_method_' . $node->type, 0) == 2 && ($max_words = variable_get('paging_automatic_words_' . $node->type, 400)) != 0) {
          // Automatic paging based on word count.
          $words = explode(' ', $node_body);
          $total_words = count($words);
          if ($total_words > $max_words) {
            $breaks = (int)($total_words / $max_words);
            for ($i = 1; $i < $breaks; $i++) {
              $index = $i * $max_words;
              $words[$index] .= $paging_separator;
            }
          }
          $body_parts = implode(' ', $words);
        }
        $node->pages = explode($paging_separator, $body_parts);
        $node->page_count = count($node->pages);
      }
      break;
    case 'view':
      /*foreach ($pages as $page) {
        preg_match('/[(?<page>\d+):]\s*(?<name>.+)/', $page, $matches);
        unset($matches[0], $matches[1], $matches[2]);
        $key = !empty($matches['page']) ? $matches['page'] : 's';
        $value = !empty($matches['name']) ? $matches['name'] : 's';
        $page_names[$key] = $value;
        d($matches);
      }  */
      if ($teaser && !($node->build_mode == NODE_BUILD_PREVIEW) && strpos($node_teaser, '<!--paging_filter-->') !== FALSE) {
        // Check to see if the teaser is longer than our first page.
        if ($node->page_count > 1 && strlen($node->teaser) > strlen($node->pages[0])) {
          $node->content['body']['#value'] = check_markup($node->pages[0], $node->format, false);
          $node->pagemore = true;
        }
      }
      break;
    case 'alter':
      if (!($node->build_mode == NODE_BUILD_PREVIEW) && strpos($teaser ? $node_teaser : $node_body, '<!--paging_filter-->') !== FALSE) {
        $element = 1;
        $page = isset($_GET['page']) ? $_GET['page'] : '';
        preg_match('<!--pagenames:(.*?)-->', $node->content['body']['#value'], $matches);
        $pages = explode('|', $matches[1]);
        // Only do paging
        // a) if not in teaser mode;
        // b) if there is more than one page;
        // c) if a printable version is not being requested; or
        // d) if a non-paged version is not being explicitly requested
        //    e.g. http://www.example.com/node/1?page=full or node/1/full.
        if (!$teaser && $node->page_count > 1 && arg(2) != 'print' && arg(2) != 'full' && $page != 'full') {
          global $pager_page_array, $pager_total;
          $pager_page_array = explode(',', $page);
          $pager_total[$element] = $node->page_count;
          $page = isset($pager_page_array[$element]) ? $pager_page_array[$element] : 0;
          $node->body = check_markup($node->pages[$page], $node->format, false);
          // Decode the comma. Ugly.
          $node->body .= '<div class="links">' . str_replace('%2C', ',', theme('pager', NULL, 1, $element)) . '</div>';
          // Remove internal <!--paging_filter--> tag from final output.
          $node->body = str_replace(array('<!--paging_filter-->', '<' . $matches[0] . '>', '&3t;' . $matches[0] . '>'), '', $node->body);
        }
        else if ($teaser) {
          // Remove internal <!--paging_filter--> tag from final output.
          $node_teaser = str_replace(array('<!--paging_filter-->', '<' . $matches[0] . '>', '&lt;' . $matches[0] . '&gt;'), '', $node_teaser);
        }
      }
      break;
  }
}

/**
 * Implementation of hook_link().
 */
function paging_link($type, $node = NULL, $teaser = FALSE) {
  $links = array();
  if ($type == 'node' && $teaser && $node->teaser && $node->pagemore && variable_get('paging_read_more_enabled_' . $node->type, 0)) {
    $links['paging_read_more'] = array(
      'title' => t('Read more'),
      'href' => drupal_get_path_alias("node/$node->nid"),
      'attributes' => array('title' => t('Read the rest of this posting.'), 'class' => 'read-more-paging'),
      'query' => 'page=0,1'
    ); 
  }
  return $links;
}

/**
 * Implementation of hook_link_alter().
 */
function paging_link_alter(&$links, $node) {
  if (!empty($node->teaser) && $node->pagemore && variable_get('paging_read_more_enabled_' . $node->type, 0)) {
    unset($links['node_read_more']);
  }
}

/**
 * Implementation of hook_filter().
 */
function paging_filter($in_op, $in_delta = 0, $in_format = -1, $in_text = '') {
  switch ($in_op) {
    case 'list':
      return array(t('Paging'));
      break;
    case 'description':
      return t('Allows content to be broken up into pages, using a separator tag (e.g. %separator), configurable on <a href="!url">paging settings page</a>.', array('%separator' => '<!--pagebreak-->', '!url' => url('admin/settings/paging')));
      break;
    case 'process':
      // The filter gets called before the nodeapi 'view' so,
      // add a comment to the body to inform the nodeapi hook to apply the filter.
      return '<!--paging_filter-->' . $in_text;
      break;
    default:
      return $in_text;
      break;
  }
}

/**
 * Implementation of hook_filter_tips().
 */
function paging_filter_tips($delta, $format, $long = FALSE) {
  if ($long) {
    return '<h1>' . t('Paging Help') . '</h1>' . paging_help('admin/help#paging');
  }
  else {
    return t('Use %separator to create page breaks.', array('%separator' => $GLOBALS['paging_sep']));
  }
}
